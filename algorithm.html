<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeconvoluteSanger 算法验证平台</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background-color: #f5f7fa; color: #333; line-height: 1.6; }
        h1, h2, h3 { color: #2c3e50; }
        .container { background-color: white; border-radius: 10px; padding: 25px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 20px; }
        .control-panel { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; align-items: center; }
        button { background-color: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; transition: background-color 0.3s; }
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        #batchBtn { background-color: #e67e22; }
        #batchBtn:hover { background-color: #d35400; }
        .sequence { font-family: monospace; font-size: 16px; letter-spacing: 2px; margin: 10px 0; padding: 10px; background-color: #ecf0f1; border-radius: 5px; border: 1px solid #ddd; overflow-x: auto; word-wrap: break-word; }
        .editable { background-color: #fff; border-color: #3498db; }
        /* 修改此处：将左右排列改为上下排列 */
        .comparison-grid { display: grid; grid-template-columns: 1fr; gap: 20px; margin-top: 20px; }
        .path-result-box { border: 1px solid #ddd; border-radius: 8px; padding: 15px; background-color: #fcfcfc; margin-bottom: 15px; }
        .match { color: #27ae60; font-weight: bold; }
        .mismatch { color: #e74c3c; font-weight: bold; }
        .input-panel { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .input-group { display: flex; flex-direction: column; }
        textarea, input[type="number"], input[type="text"] { font-family: monospace; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: 100%; box-sizing: border-box; }
        label { margin-bottom: 5px; font-weight: bold; }
        .highlight { background-color: #ffeb3b; border-radius: 3px; padding: 2px 4px; }
        .info-box { background-color: #e8f4fd; border-left: 4px solid #3498db; padding: 15px; margin: 15px 0; border-radius: 5px; }
        .validation-status { padding: 8px; border-radius: 5px; text-align: center; font-weight: bold; margin-top: 10px; }
        .validation-pass { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .validation-fail { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        #batch-simulation-box { border-top: 2px solid #e67e22; margin-top: 30px; padding-top: 20px; }
        #progress-bar-container { width: 100%; background-color: #ecf0f1; border-radius: 5px; overflow: hidden; }
        #progress-bar { width: 0%; height: 20px; background-color: #27ae60; text-align: center; color: white; line-height: 20px; transition: width 0.2s; }
        .results-table { width: 100%; margin-top: 15px; border-collapse: collapse; }
        .results-table th, .results-table td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        .results-table th { background-color: #f2f2f2; }
        .sequence-preview .input-group { display: flex; align-items: center; gap: 10px; }
        .sequence-preview .sequence, .sequence-preview input { flex-grow: 1; margin: 0; }
        .sequence-preview label { flex-shrink: 0; margin-bottom: 0; }
        details { margin-top: 20px; border: 1px solid #ddd; border-radius: 5px; }
        summary { font-weight: bold; padding: 10px; cursor: pointer; background-color: #f8f9fa; }
        #log-table-container { max-height: 400px; overflow-y: auto; padding: 10px; }
        #log-table td { font-size: 12px; word-break: break-all; }
        
        /* 语言切换按钮样式 */
        .language-switcher { display: flex; justify-content: flex-end; margin-bottom: 20px; }
        .lang-btn { background-color: #f1f1f1; color: #333; border: 1px solid #ddd; margin-left: 5px; }
        .lang-btn.active { background-color: #3498db; color: white; }
    </style>
</head>
<body>
    <!-- 语言切换按钮 -->
    <div class="language-switcher">
        <button id="langZh" class="lang-btn active">中文</button>
        <button id="langEn" class="lang-btn">English</button>
    </div>

    <div class="container">
        <h1 data-i18n="title">DeconvoluteSanger 算法验证平台</h1>
        
        <!-- Manual Analysis Section -->
        <div id="manual-analysis-box">
            <h2 data-i18n="manualAnalysis">手动单次分析</h2>
            <div class="control-panel">
                <button id="generateBtn" data-i18n="generateRandom">生成随机碱基序列</button>
                <button id="useInputBtn" data-i18n="useInput">使用输入框序列</button>
                <button id="analyzeBtn" data-i18n="executeAnalysis">执行算法解析</button>
            </div>
            <div class="input-panel">
                 <div class="input-group">
                    <label for="sequenceLength" data-i18n="sequenceLength">序列长度:</label>
                    <input type="number" id="sequenceLength" value="7" min="4">
                </div>
                <div class="input-group">
                    <label for="deletionPosInput" data-i18n="deletionPosition">缺失位置 (从1开始):</label>
                    <input type="number" id="deletionPosInput" value="3" min="2">
                </div>
            </div>
            <div class="input-group" style="margin-bottom: 20px;">
                <label for="originalInput" data-i18n="originalSequence">原始序列 (HapA):</label>
                <textarea id="originalInput" data-i18n-placeholder="originalPlaceholder">ACTTTTT</textarea>
            </div>
            <div class="sequence-container sequence-preview">
                <h3 data-i18n="sequencePreview">输入序列预览</h3>
                <p><strong data-i18n="originalSequence">原始序列 (HapA):</strong> <span id="originalSequence" class="sequence"></span></p>
                <p><strong data-i18n="variantSequence">变异序列 (HapB):</strong> <span id="variantSequence" class="sequence"></span></p>
                <div class="input-group">
                    <label for="mixedSequenceInput" data-i18n="editableMixedSignal">可编辑的混合信号:</label>
                    <input type="text" id="mixedSequenceInput" class="sequence editable">
                </div>
            </div>
            <div class="container">
                <div id="pathInfo" class="info-box" style="display:none;"></div>
                <!-- 修改此处：路径结果改为上下排列 -->
                <div class="comparison-grid">
                    <div class="path-result-box">
                        <h3 data-i18n="pathA">路径 A 推理结果</h3>
                        <p><strong data-i18n="hapA">HapA:</strong> <span id="parsedHapA_A" class="sequence"></span></p>
                        <p><strong data-i18n="hapB">HapB:</strong> <span id="parsedHapB_A" class="sequence"></span></p>
                        <div id="validation_A" class="validation-status"></div>
                    </div>
                    <div class="path-result-box">
                        <h3 data-i18n="pathB">路径 B 推理结果</h3>
                        <p><strong data-i18n="hapA">HapA:</strong> <span id="parsedHapA_B" class="sequence"></span></p>
                        <p><strong data-i18n="hapB">HapB:</strong> <span id="parsedHapB_B" class="sequence"></span></p>
                        <div id="validation_B" class="validation-status"></div>
                    </div>
                </div>
                <div id="resultSummary" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Batch Simulation Section -->
        <div id="batch-simulation-box" class="container">
            <h2 data-i18n="batchSimulation">计算机模拟批量验证</h2>
            <div class="input-panel">
                <div class="input-group">
                    <label for="batchRuns" data-i18n="simulationCount">模拟次数:</label>
                    <input type="number" id="batchRuns" value="1000" min="10">
                </div>
                <div class="input-group">
                    <label for="batchLength" data-i18n="sequenceLengthBp">序列长度 (bp):</label>
                    <input type="number" id="batchLength" value="800" min="25">
                </div>
            </div>
            <button id="batchBtn" data-i18n="startSimulation">开始模拟验证</button>
            <div id="progress-container" style="margin-top: 20px; display: none;">
                <p><strong data-i18n="processingProgress">处理进度:</strong> <span id="progress-text">0 / 1000</span></p>
                <div id="progress-bar-container"><div id="progress-bar">0%</div></div>
                <table id="batch-results-table" class="results-table">
                    <thead>
                        <tr>
                            <th data-i18n="resultCategory">结果分类</th>
                            <th data-i18n="count">数量</th>
                            <th data-i18n="percentage">百分比</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td data-i18n="uniqueSuccess">唯一解成功</td>
                            <td id="success-count">0</td>
                            <td id="success-percent">0.00%</td>
                        </tr>
                        <tr>
                            <td data-i18n="ambiguousResult">歧义解识别</td>
                            <td id="ambiguous-count">0</td>
                            <td id="ambiguous-percent">0.00%</td>
                        </tr>
                        <tr>
                            <td data-i18n="parseFailed">解析失败</td>
                            <td id="fail-count">0</td>
                            <td id="fail-percent">0.00%</td>
                        </tr>
                        <tr>
                            <td><strong data-i18n="total">总计</strong></td>
                            <td id="total-count">0</td>
                            <td id="total-percent">100.00%</td>
                        </tr>
                    </tbody>
                </table>
                <details>
                    <summary data-i18n="exceptionLogs">异常案例日志 (歧义解与失败)</summary>
                    <div id="log-table-container">
                        <table id="log-table" class="results-table">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th data-i18n="resultType">结果类型</th>
                                    <th data-i18n="deletionPosition">缺失位置</th>
                                    <th data-i18n="originalSequence">原始序列 (HapA)</th>
                                </tr>
                            </thead>
                            <tbody id="log-body"></tbody>
                        </table>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <script>
        // 语言资源对象
        const languageResources = {
            'zh-CN': {
                'title': 'DeconvoluteSanger 算法验证平台',
                'manualAnalysis': '手动单次分析',
                'batchSimulation': '计算机模拟批量验证',
                'generateRandom': '生成随机碱基序列',
                'useInput': '使用输入框序列',
                'executeAnalysis': '执行算法解析',
                'sequenceLength': '序列长度:',
                'deletionPosition': '缺失位置 (从1开始):',
                'originalSequence': '原始序列 (HapA):',
                'variantSequence': '变异序列 (HapB):',
                'editableMixedSignal': '可编辑的混合信号:',
                'sequencePreview': '输入序列预览',
                'pathA': '路径 A 推理结果',
                'pathB': '路径 B 推理结果',
                'hapA': 'HapA:',
                'hapB': 'HapB:',
                'simulationCount': '模拟次数:',
                'sequenceLengthBp': '序列长度 (bp):',
                'startSimulation': '开始模拟验证',
                'processingProgress': '处理进度:',
                'resultCategory': '结果分类',
                'count': '数量',
                'percentage': '百分比',
                'uniqueSuccess': '唯一解成功',
                'ambiguousResult': '歧义解识别',
                'parseFailed': '解析失败',
                'total': '总计',
                'exceptionLogs': '异常案例日志 (歧义解与失败)',
                'resultType': '结果类型',
                'originalPlaceholder': '点击"生成随机碱基序列"或在此处手动输入...',
                // 新增的翻译项
                'parseFailedNoOverlap': '解析失败: 输入信号不包含任何套峰，与杂合缺失模型不符。',
                'randomForkAt': '在位点 {position} 处随机分叉。',
                'successResult': '成功',
                'ambiguousResultType': '歧义',
                'failResultType': '失败'
            },
            'en': {
                'title': 'DeconvoluteSanger Algorithm Validation Platform',
                'manualAnalysis': 'Manual Single Analysis',
                'batchSimulation': 'Computer Simulation Batch Validation',
                'generateRandom': 'Generate Random Base Sequence',
                'useInput': 'Use Input Box Sequence',
                'executeAnalysis': 'Execute Algorithm Analysis',
                'sequenceLength': 'Sequence Length:',
                'deletionPosition': 'Deletion Position (from 1):',
                'originalSequence': 'Original Sequence (HapA):',
                'variantSequence': 'Variant Sequence (HapB):',
                'editableMixedSignal': 'Editable Mixed Signal:',
                'sequencePreview': 'Input Sequence Preview',
                'pathA': 'Path A Inference Result',
                'pathB': 'Path B Inference Result',
                'hapA': 'HapA:',
                'hapB': 'HapB:',
                'simulationCount': 'Simulation Count:',
                'sequenceLengthBp': 'Sequence Length (bp):',
                'startSimulation': 'Start Simulation Validation',
                'processingProgress': 'Processing Progress:',
                'resultCategory': 'Result Category',
                'count': 'Count',
                'percentage': 'Percentage',
                'uniqueSuccess': 'Unique Solution Success',
                'ambiguousResult': 'Ambiguous Solution Identified',
                'parseFailed': 'Parse Failed',
                'total': 'Total',
                'exceptionLogs': 'Exception Case Logs (Ambiguous & Failed)',
                'resultType': 'Result Type',
                'originalPlaceholder': 'Click "Generate Random Base Sequence" or manually input here...',
                // 新增的翻译项
                'parseFailedNoOverlap': 'Parse failed: Input signal does not contain any overlapping peaks, inconsistent with heterozygous deletion model.',
                'randomForkAt': 'Random fork at position {position}.',
                'successResult': 'Success',
                'ambiguousResultType': 'Ambiguous',
                'failResultType': 'Fail'
            }
        };

        // 当前语言
        let currentLanguage = localStorage.getItem('preferredLanguage') || 'zh-CN';

        // 切换语言函数
        function switchLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('preferredLanguage', lang);
            
            // 更新所有带有data-i18n属性的元素
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (languageResources[lang][key]) {
                    element.textContent = languageResources[lang][key];
                }
            });
            
            // 更新带有data-i18n-placeholder属性的元素
            document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                const key = element.getAttribute('data-i18n-placeholder');
                if (languageResources[lang][key]) {
                    element.setAttribute('placeholder', languageResources[lang][key]);
                }
            });
            
            // 更新按钮激活状态
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`lang${lang === 'zh-CN' ? 'Zh' : 'En'}`).classList.add('active');
            
            // 更新验证状态文本
            updateValidationTexts();
        }
        
        // 更新验证状态文本
        function updateValidationTexts() {
            const validationElements = document.querySelectorAll('.validation-status');
            validationElements.forEach(element => {
                if (element.textContent === '验证通过' || element.textContent === 'Validation Passed') {
                    element.textContent = currentLanguage === 'zh-CN' ? '验证通过' : 'Validation Passed';
                } else if (element.textContent === '验证失败' || element.textContent === 'Validation Failed') {
                    element.textContent = currentLanguage === 'zh-CN' ? '验证失败' : 'Validation Failed';
                }
            });
            
            // 更新结果摘要
            const resultSummary = document.getElementById('resultSummary');
            if (resultSummary.innerHTML.includes('结论')) {
                if (resultSummary.innerHTML.includes('找到唯一有效解')) {
                    resultSummary.innerHTML = `<div class="match" style="font-size: 18px; font-weight: bold;">${currentLanguage === 'zh-CN' ? '结论: 找到唯一有效解。' : 'Conclusion: Found a unique valid solution.'}</div>`;
                } else if (resultSummary.innerHTML.includes('结果存在歧义')) {
                    resultSummary.innerHTML = `<div class="mismatch" style="font-size: 18px; font-weight: bold;">${currentLanguage === 'zh-CN' ? '结论: 结果存在歧义！' : 'Conclusion: Result is ambiguous!'}</div>`;
                } else if (resultSummary.innerHTML.includes('解析失败')) {
                    resultSummary.innerHTML = `<div class="mismatch" style="font-size: 18px; font-weight: bold;">${currentLanguage === 'zh-CN' ? '结论: 解析失败。' : 'Conclusion: Parse failed.'}</div>`;
                }
            }
        }

        const bases = ['A', 'T', 'C', 'G'];
        let originalSequence = '', variantSequence = '', mixedSequence = [], deletionPosition = -1;
        const dom = {
            originalSequence: document.getElementById('originalSequence'), variantSequence: document.getElementById('variantSequence'), mixedSequenceInput: document.getElementById('mixedSequenceInput'),
            parsedHapA_A: document.getElementById('parsedHapA_A'), parsedHapB_A: document.getElementById('parsedHapB_A'), validation_A: document.getElementById('validation_A'),
            parsedHapA_B: document.getElementById('parsedHapA_B'), parsedHapB_B: document.getElementById('parsedHapB_B'), validation_B: document.getElementById('validation_B'),
            resultSummary: document.getElementById('resultSummary'), originalInput: document.getElementById('originalInput'), pathInfo: document.getElementById('pathInfo'),
            deletionPosInput: document.getElementById('deletionPosInput'), sequenceLength: document.getElementById('sequenceLength'),
            batchBtn: document.getElementById('batchBtn'), batchRuns: document.getElementById('batchRuns'), batchLength: document.getElementById('batchLength'),
            progressContainer: document.getElementById('progress-container'), progressText: document.getElementById('progress-text'), progressBar: document.getElementById('progress-bar'),
            successCount: document.getElementById('success-count'), successPercent: document.getElementById('success-percent'),
            ambiguousCount: document.getElementById('ambiguous-count'), ambiguousPercent: document.getElementById('ambiguous-percent'),
            failCount: document.getElementById('fail-count'), failPercent: document.getElementById('fail-percent'),
            totalCount: document.getElementById('total-count'),
            logBody: document.getElementById('log-body')
        };
        const generateBtn = document.getElementById('generateBtn'), analyzeBtn = document.getElementById('analyzeBtn'), useInputBtn = document.getElementById('useInputBtn');
        
        function generateRandomSequence(length) { let seq = ''; for (let i = 0; i < length; i++) seq += bases[Math.floor(Math.random() * bases.length)]; return seq; }
        function createVariantSequence(sequence, delPos) { deletionPosition = delPos - 1; return sequence.substring(0, deletionPosition) + sequence.substring(deletionPosition + 1); }
        function createMixedSequence(original, variant) { const mixed = []; for (let i = 0; i < original.length; i++) { if (i < variant.length) { mixed.push([original[i], variant[i]]); } else { mixed.push([original[i]]); } } return mixed; }
        function formatMixedSequenceToString(mixed) { return mixed.map(bases => [...new Set(bases)].sort().join('/')).join(' '); }
        function parseEditableMixedSequence(text) { const parts = text.trim().split(/\s+/).filter(p => p); return parts.map(part => part.split('/')); }
        
        function deconvoluteWithSingleFork(mixedSeq) {
            let commonPath = { HapA: [], HapB: [] }; let forkIndex = -1;
            for (let i = 0; i < mixedSeq.length; i++) { 
                if ([...new Set(mixedSeq[i])].length === 1) { 
                    commonPath.HapA.push(mixedSeq[i][0]); 
                    commonPath.HapB.push(mixedSeq[i][0]); 
                } else { 
                    forkIndex = i; 
                    break; 
                } 
            }
            
            if (forkIndex === -1) {
                const finalPath = {HapA: commonPath.HapA, HapB: commonPath.HapB};
                return { 
                    winner: 'None', 
                    pathA: finalPath, 
                    pathB: JSON.parse(JSON.stringify(finalPath)), 
                    isAValid: false, 
                    isBValid: false, 
                    info: languageResources[currentLanguage]['parseFailedNoOverlap']
                };
            }

            let forkBases = [...new Set(mixedSeq[forkIndex])]; 
            if (Math.random() < 0.5) { forkBases = [forkBases[1], forkBases[0]]; }
            const pathA = JSON.parse(JSON.stringify(commonPath)); 
            pathA.HapA.push(forkBases[0]); 
            pathA.HapB.push(forkBases[1]);
            const pathB = JSON.parse(JSON.stringify(commonPath)); 
            pathB.HapA.push(forkBases[1]); 
            pathB.HapB.push(forkBases[0]);
            const completedPathA = _completePathGreedily_consistent(mixedSeq, pathA, forkIndex + 1);
            const completedPathB = _completePathGreedily_consistent(mixedSeq, pathB, forkIndex + 1);
            const isAValid = validatePath(completedPathA.HapA.join(''), completedPathA.HapB.join(''));
            const isBValid = validatePath(completedPathB.HapA.join(''), completedPathB.HapB.join(''));
            let winner = 'None';
            if (isAValid && !isBValid) winner = 'A'; 
            else if (!isAValid && isBValid) winner = 'B'; 
            else if (isAValid && isBValid) winner = 'Both';
            
            // 使用语言资源中的文本，并替换占位符
            const forkPosition = forkIndex + 1;
            const infoTemplate = languageResources[currentLanguage]['randomForkAt'];
            const infoText = infoTemplate.replace('{position}', forkPosition);
            
            return { 
                winner, 
                pathA: completedPathA, 
                pathB: completedPathB, 
                isAValid, 
                isBValid, 
                info: infoText
            };
        }
        const _decideAllocation = (current_base, prev_hap_b_base, next_bases) => { const l = next_bases && next_bases.includes(current_base); if (!l) return 'HapA'; if (prev_hap_b_base && prev_hap_b_base === current_base) return 'HapA'; return 'HapB'; };
        function _completePathGreedily_consistent(mixedSeq, currentPath, startIndex) {
             for (let i = startIndex; i < mixedSeq.length; i++) {
                const u = [...new Set(mixedSeq[i])];
                if (u.length === 1) {
                    if (i === mixedSeq.length - 1 && i > 0 && u[0] === currentPath.HapB[i-1]) { currentPath.HapA.push(u[0]); }
                    else { currentPath.HapA.push(u[0]); currentPath.HapB.push(u[0]); }
                } else {
                    const [b1, b2] = u, p = (i > 0) ? currentPath.HapB[i - 1] : null, n = (i < mixedSeq.length - 1) ? mixedSeq[i + 1] : null;
                    const a1 = _decideAllocation(b1, p, n), a2 = _decideAllocation(b2, p, n);
                    if (a1 !== a2) { if (a1 === 'HapA') { currentPath.HapA.push(b1); currentPath.HapB.push(b2); } else { currentPath.HapA.push(b2); currentPath.HapB.push(b1); } }
                    else { currentPath.HapA.push(b1); currentPath.HapB.push(b2); }
                }
            }
            return currentPath;
        }
        function validatePath(hA, hB) { if (hA.length !== hB.length + 1) return false; for (let i = 0; i < hA.length; i++) { if ((hA.substring(0, i) + hA.substring(i + 1)) === hB) return true; } return false; }

        function runSetup(source = 'input') {
            if (source === 'random') {
                const l = parseInt(dom.sequenceLength.value); if (isNaN(l) || l < 4) { alert(currentLanguage === 'zh-CN' ? '请输入有效的序列长度 (至少为4)' : 'Please enter a valid sequence length (at least 4)'); return false; }
                originalSequence = generateRandomSequence(l); dom.originalInput.value = originalSequence;
            } else {
                originalSequence = dom.originalInput.value.trim().toUpperCase().replace(/[^ATCG]/g, ''); if (!originalSequence) { alert(currentLanguage === 'zh-CN' ? '请输入有效的原始序列' : 'Please enter a valid original sequence'); return false; }
                dom.originalInput.value = originalSequence; dom.sequenceLength.value = originalSequence.length;
            }
            const d = parseInt(dom.deletionPosInput.value), m = originalSequence.length - 1;
            if (isNaN(d) || d < 2 || d > m) { alert(currentLanguage === 'zh-CN' ? `对当前长度为 ${originalSequence.length} 的序列，请输入有效的缺失位置 (2 到 ${m} 之间)` : `For the current sequence of length ${originalSequence.length}, please enter a valid deletion position (between 2 and ${m})`); return false; }
            variantSequence = createVariantSequence(originalSequence, d); mixedSequence = createMixedSequence(originalSequence, variantSequence);
            updateManualDisplay(); return true;
        }
        function updateManualDisplay() {
            dom.originalSequence.innerHTML = originalSequence.substring(0, deletionPosition) + `<span class="highlight">${originalSequence[deletionPosition]}</span>` + originalSequence.substring(deletionPosition + 1);
            dom.variantSequence.textContent = variantSequence;
            dom.mixedSequenceInput.value = formatMixedSequenceToString(mixedSequence);
            dom.parsedHapA_A.textContent = ''; dom.parsedHapB_A.textContent = ''; dom.validation_A.innerHTML = ''; dom.validation_A.className = 'validation-status';
            dom.parsedHapA_B.textContent = ''; dom.parsedHapB_B.textContent = ''; dom.validation_B.innerHTML = ''; dom.validation_B.className = 'validation-status';
            dom.resultSummary.innerHTML = ''; dom.pathInfo.style.display = 'none';
        }
        function analyzeSequence() {
            const userMixedSequence = parseEditableMixedSequence(dom.mixedSequenceInput.value);
            if (!userMixedSequence || userMixedSequence.length === 0) { alert(currentLanguage === 'zh-CN' ? "混合信号为空！" : "Mixed signal is empty!"); return; }
            const result = deconvoluteWithSingleFork(userMixedSequence);
            dom.pathInfo.style.display = 'block'; dom.pathInfo.innerHTML = result.info;
            dom.parsedHapA_A.textContent = result.pathA.HapA.join(''); dom.parsedHapB_A.textContent = result.pathA.HapB.join('');
            dom.validation_A.innerHTML = result.isAValid ? (currentLanguage === 'zh-CN' ? '验证通过' : 'Validation Passed') : (currentLanguage === 'zh-CN' ? '验证失败' : 'Validation Failed');
            dom.validation_A.className = `validation-status ${result.isAValid ? 'validation-pass' : 'validation-fail'}`;
            dom.parsedHapA_B.textContent = result.pathB.HapA.join(''); dom.parsedHapB_B.textContent = result.pathB.HapB.join('');
            dom.validation_B.innerHTML = result.isBValid ? (currentLanguage === 'zh-CN' ? '验证通过' : 'Validation Passed') : (currentLanguage === 'zh-CN' ? '验证失败' : 'Validation Failed');
            dom.validation_B.className = `validation-status ${result.isBValid ? 'validation-pass' : 'validation-fail'}`;
            let summaryHTML;
            switch(result.winner) {
                case 'A': case 'B': summaryHTML = `<div class="match" style="font-size: 18px; font-weight: bold;">${currentLanguage === 'zh-CN' ? '结论: 找到唯一有效解。' : 'Conclusion: Found a unique valid solution.'}</div>`; break;
                case 'Both': summaryHTML = `<div class="mismatch" style="font-size: 18px; font-weight: bold;">${currentLanguage === 'zh-CN' ? '结论: 结果存在歧义！' : 'Conclusion: Result is ambiguous!'}</div>`; break;
                default: summaryHTML = `<div class="mismatch" style="font-size: 18px; font-weight: bold;">${currentLanguage === 'zh-CN' ? '结论: 解析失败。' : 'Conclusion: Parse failed.'}</div>`; break;
            }
            dom.resultSummary.innerHTML = summaryHTML;
        }

        async function runBatchSimulation() {
            dom.batchBtn.disabled = true; 
            dom.progressContainer.style.display = 'block'; 
            dom.logBody.innerHTML = '';
            const totalRuns = parseInt(dom.batchRuns.value), seqLength = parseInt(dom.batchLength.value);
            const counts = { success: 0, ambiguous: 0, fail: 0 };
            let logCounter = 1;
            
            for (let i = 0; i < totalRuns; i++) {
                const batchOS = generateRandomSequence(seqLength);
                const batchDP = Math.floor(Math.random() * 16) + 5; // Random pos between 5 and 20
                const batchVS = createVariantSequence(batchOS, batchDP);
                const batchMS = createMixedSequence(batchOS, batchVS);
                const result = deconvoluteWithSingleFork(batchMS);
                
                let resultType = '';
                if (result.winner === 'A' || result.winner === 'B') { 
                    counts.success++; 
                    resultType = languageResources[currentLanguage]['successResult']; 
                }
                else if (result.winner === 'Both') { 
                    counts.ambiguous++; 
                    resultType = languageResources[currentLanguage]['ambiguousResultType']; 
                }
                else { 
                    counts.fail++; 
                    resultType = languageResources[currentLanguage]['failResultType']; 
                }
                
                if (resultType !== languageResources[currentLanguage]['successResult']) {
                    const logRow = dom.logBody.insertRow();
                    logRow.innerHTML = `<td>${logCounter++}</td><td><span class="mismatch">${resultType}</span></td><td>${batchDP}</td><td>${batchOS}</td>`;
                }
                
                // 进度更新部分
                if ((i + 1) % 20 === 0 || i === totalRuns - 1) {
                    const pC = i + 1, pct = (pC / totalRuns) * 100;
                    dom.progressText.textContent = `${pC} / ${totalRuns}`;
                    dom.progressBar.style.width = `${pct}%`; 
                    dom.progressBar.textContent = `${pct.toFixed(1)}%`;
                    dom.successCount.textContent = counts.success; 
                    dom.ambiguousCount.textContent = counts.ambiguous; 
                    dom.failCount.textContent = counts.fail; 
                    dom.totalCount.textContent = pC;
                    dom.successPercent.textContent = `${((counts.success / pC) * 100).toFixed(2)}%`;
                    dom.ambiguousPercent.textContent = `${((counts.ambiguous / pC) * 100).toFixed(2)}%`;
                    dom.failPercent.textContent = `${((counts.fail / pC) * 100).toFixed(2)}%`;
                    await new Promise(r => setTimeout(r, 0)); 
                }
            }
            dom.batchBtn.disabled = false;
        }

        // 初始化语言
        switchLanguage(currentLanguage);
        
        // 事件监听
        generateBtn.addEventListener('click', () => runSetup('random'));
        useInputBtn.addEventListener('click', () => runSetup('input'));
        analyzeBtn.addEventListener('click', analyzeSequence);
        dom.batchBtn.addEventListener('click', runBatchSimulation);
        
        // 语言切换按钮事件
        document.getElementById('langZh').addEventListener('click', () => switchLanguage('zh-CN'));
        document.getElementById('langEn').addEventListener('click', () => switchLanguage('en'));
        
        runSetup('input');
    </script>
</body>
</html>
